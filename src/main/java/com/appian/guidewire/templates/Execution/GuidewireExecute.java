package com.appian.guidewire.templates.Execution;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import com.appian.connectedsystems.simplified.sdk.configuration.SimpleConfiguration;
import com.appian.connectedsystems.templateframework.sdk.ExecutionContext;
import com.appian.connectedsystems.templateframework.sdk.IntegrationError;
import com.appian.connectedsystems.templateframework.sdk.IntegrationResponse;
import com.appian.connectedsystems.templateframework.sdk.configuration.PropertyState;

import std.Util;

public class GuidewireExecute extends Execute {

  public GuidewireExecute(
      SimpleConfiguration integrationConfiguration,
      SimpleConfiguration connectedSystemConfiguration,
      ExecutionContext executionContext) {
    super(integrationConfiguration, connectedSystemConfiguration, executionContext);
  }

  @Override
  public IntegrationResponse buildExecution() throws IOException {
    try {
      switch (restOperation) {
        case GET:
          executeGet();
          break;
        case DELETE:
          executeDelete();
          break;
        case POST:
          executePost();
          break;
        case PATCH:
          executePatch();
          break;
      }
    } catch (IOException e) {
      return IntegrationResponse.forError(new IntegrationError.IntegrationErrorBuilder()
              .title(e.getCause().toString())
              .message(e.getMessage())
              .build())
          .build();
    }

    // If autogenerated 'text' property is submitted, null value submitted, or other errors created, return error
    if (getError() != null) {
      IntegrationError error = getError().build();
      return getDiagnosticsUI() != null ?
          IntegrationResponse.forError(error).withDiagnostic(getDiagnosticsUI()).build() :
          IntegrationResponse.forError(error).build();
    }

    return IntegrationResponse.forSuccess(
            getResponse()).withDiagnostic(getDiagnosticsUI())
        .build();
  }

  @Override
  public void executeGet() throws IOException {

    pathNameModified += "?";
    // Pagination
    // TODO: pagination with next parameter
    int pageSize = integrationConfiguration.getValue(PAGESIZE) != null ? integrationConfiguration.getValue(PAGESIZE) : 0;
    if (pageSize > 0) {
      pathNameModified = pathNameModified + "pageSize=" + pageSize + "&";
    }

    // Included Resources
    String includedResourcesKey = Util.removeSpecialCharactersFromPathName(pathNameUnmodified) + INCLUDED_RESOURCES;
    Map<String,PropertyState> includedMap = integrationConfiguration.getValue(includedResourcesKey);
    if (includedMap != null && includedMap.size() > 0) {
      AtomicBoolean firstIncluded = new AtomicBoolean(true);
      includedMap.entrySet().forEach(entry -> {
        if (entry.getValue().getValue().equals(true)) {
          pathNameModified += firstIncluded.get() ? "include=" + entry.getKey() + "," : entry.getKey() + ",";
          firstIncluded.set(false);
        }
      });
      pathNameModified = Util.removeLastChar(pathNameModified) + "&";
    }

    // Sorting
    String sortField = integrationConfiguration.getValue(SORT);
    String sortOrder = integrationConfiguration.getValue(SORT_ORDER);
    if (sortField != null && sortOrder != null) {
      pathNameModified += sortOrder.equals("-") ?
          "sort=-" + sortField + "&" :
          "sort=" + sortField + "&";
    }

    // Filtering
    String filterField = Util.filterRules(integrationConfiguration.getValue(FILTER_FIELD));
    String filterOperator = Util.filterRules(integrationConfiguration.getValue(FILTER_OPERATOR));
    String filterValue = Util.filterRules(integrationConfiguration.getValue(FILTER_VALUE));
    if (filterField != null && filterOperator  != null && filterValue != null) {
      pathNameModified += "filter=" + filterField + ":" + filterOperator + ":" + filterValue + "&";
    }

    // Include Total
    pathNameModified = pathNameModified + "includeTotal=true";

    // If none of the above options were set or if options have been set and there are no more edits required to the pathName
/*    String lastChar = pathNameModified.substring(pathNameModified.length() - 1);
    if (lastChar.equals("&") || lastChar.equals("?")) {
      pathNameModified = Util.removeLastChar(pathNameModified);
    }*/

    this.HTTPResponse = httpService.get(pathNameModified);

    System.out.println(pathNameModified);
  }

  @Override
  public void executePost() throws IOException {
    HashMap<String, PropertyState> reqBodyProperties = integrationConfiguration.getValue(reqBodyKey);
    buildRequestBodyJSON(reqBodyProperties);
  }

  @Override
  public void executePatch() throws IOException {
    HashMap<String, PropertyState> reqBodyProperties = integrationConfiguration.getValue(reqBodyKey);
    buildRequestBodyJSON(reqBodyProperties);
  }

  @Override
  public void executeDelete() throws IOException {

  }
}
