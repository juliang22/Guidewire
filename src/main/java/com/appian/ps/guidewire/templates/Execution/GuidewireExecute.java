package com.appian.ps.guidewire.templates.Execution;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.commons.io.IOUtils;
import org.apache.tika.mime.MimeTypeException;

import com.appian.connectedsystems.simplified.sdk.configuration.SimpleConfiguration;
import com.appian.connectedsystems.templateframework.sdk.ExecutionContext;
import com.appian.connectedsystems.templateframework.sdk.IntegrationResponse;
import com.appian.connectedsystems.templateframework.sdk.configuration.Document;
import com.appian.connectedsystems.templateframework.sdk.configuration.PropertyState;
import com.appian.ps.guidewire.templates.HTTP.HttpResponse;
import com.fasterxml.jackson.databind.ObjectMapper;

import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.RequestBody;
import std.Util;

public class GuidewireExecute extends Execute {

  public GuidewireExecute(SimpleConfiguration integrationConfiguration, SimpleConfiguration connectedSystemConfiguration,
      ExecutionContext executionContext) throws IOException, MimeTypeException {
    super(integrationConfiguration, connectedSystemConfiguration, executionContext);

    String[] pathData = integrationConfiguration.getValue(CHOSEN_ENDPOINT).toString().split(":");
    this.api = pathData[0];
    this.restOperation = pathData[1];
    this.pathNameUnmodified = pathData[2];
    this.subApi = pathData[3];
    String subApiInfoStr = integrationConfiguration.getValue(SUB_API_TYPE);
    this.apiInfoMap = objectMapper.readValue(subApiInfoStr, Map.class);
    String rootUrl = connectedSystemConfiguration.getValue(ROOT_URL);

    String module = apiInfoMap.get("basePath");
    String version = connectedSystemConfiguration.getValue(VERSION).toString();
    String basePath = module.substring(0, module.lastIndexOf("/") + 1) + version;

    this.pathNameModified = rootUrl + "/rest" + basePath + pathNameUnmodified;
    this.reqBodyKey = Util.removeSpecialCharactersFromPathName(pathNameUnmodified);
    buildPathNameWithPathVars();
  }

  @Override
  public IntegrationResponse buildExecution() throws IOException {
    try {
      switch (restOperation) {
        case GET:
          executeGet();
          break;
        case DELETE:
          executeDelete();
          break;
        case POST:
          executePost();
          break;
        case PATCH:
          executePatch();
          break;
      }
    } catch (IOException | MimeTypeException e) {
      return IntegrationResponse
          .forError(Util.buildError(e.getCause().toString(), e.getMessage(), ""))
          .withDiagnostic(getDiagnosticsUI())
          .build();
    }

    // If autogenerated 'text' property is submitted, null value submitted, or other errors created, return error
    if (httpService.getHttpError() != null) {
      HttpResponse httpError = httpService.getHttpError();
      return IntegrationResponse
          .forError(Util.buildError("Error " + httpError.getStatusCode(), httpError.getResponse().toString(), httpError.getStatusLine()))
          .withDiagnostic(getDiagnosticsUI())
          .build();
    }
    return IntegrationResponse
        .forSuccess(httpService.getHttpResponse().getCombinedResponse())
        .withDiagnostic(getDiagnosticsUI())
        .build();
  }

  @Override
  public void executeGet() throws IOException, MimeTypeException {

    pathNameModified += "?";
    // Pagination
    String pageSize = integrationConfiguration.getValue(PAGESIZE);
    if (pageSize != null) {
      if (Util.isInteger(pageSize) && Integer.parseInt(pageSize) > 0) { // Pagesize is just a number
        pathNameModified = pathNameModified + "pageSize=" + pageSize + "&";
      } else { // pagesize is a link to next/prev href
        // merge next/prev link into pathName
        String nextOrPrevPagination = Util.mergeStrings(pathNameModified, pageSize);
        httpService.get(nextOrPrevPagination);
        return;
      }
    }

    // Included Resources exist and have been selected by user
    String includedResourcesKey = Util.removeSpecialCharactersFromPathName(pathNameUnmodified) + INCLUDED_RESOURCES;
    Map<String,PropertyState> includedMap = integrationConfiguration.getValue(includedResourcesKey);
    boolean includedPropertiesSelected = Optional.ofNullable(includedMap)
        .filter(m -> !m.isEmpty())
        .map(m -> m.values().stream().anyMatch(val -> Boolean.parseBoolean(val.getValue().toString())))
        .orElse(false);
    if (includedPropertiesSelected) {
      AtomicBoolean firstIncluded = new AtomicBoolean(true);
      includedMap.entrySet().forEach(entry -> {
        if (entry.getValue().getValue().equals(true)) {
          pathNameModified += firstIncluded.get() ? "include=" + entry.getKey() + "," : entry.getKey() + ",";
          firstIncluded.set(false);
        }
      });
      pathNameModified = Util.removeLastChar(pathNameModified) + "&";
    }

    // Sorting
    String sortField = integrationConfiguration.getValue(SORT);
    String sortOrder = integrationConfiguration.getValue(SORT_ORDER);
    if (sortField != null && sortOrder != null) {
      pathNameModified += sortOrder.equals("-") ?
          "sort=-" + sortField + "&" :
          "sort=" + sortField + "&";
    }

    // Filtering
    String filterField = Util.filterRules(integrationConfiguration.getValue(FILTER_FIELD));
    String filterOperator = Util.filterRules(integrationConfiguration.getValue(FILTER_OPERATOR));
    String filterValue = Util.filterRules(integrationConfiguration.getValue(FILTER_VALUE));
    if (filterField != null && filterOperator  != null && filterValue != null) {
      pathNameModified += "filter=" + filterField + ":" + filterOperator + ":" + filterValue + "&";
    }

    // Include Total
    pathNameModified = integrationConfiguration.getProperty(INCLUDE_TOTAL) != null && integrationConfiguration.getValue(INCLUDE_TOTAL).equals(true) ?
        pathNameModified + "includeTotal=true" :
        pathNameModified;

    // If none of the above options were set or if options have been set and there are no more edits required to the pathName
    String lastChar = pathNameModified.substring(pathNameModified.length() - 1);
    if (lastChar.equals("&") || lastChar.equals("?")) {
      pathNameModified = Util.removeLastChar(pathNameModified);
    }

    httpService.get(pathNameModified);
  }

  public RequestBody getCompletedRequestBody() throws IOException {

    // If composite request
    if (pathNameUnmodified.equals("/composite") && integrationConfiguration.getProperty(COMPOSITE) != null) {
      // TODO: Check if JSON is well formed

      String compositeProp = integrationConfiguration.getValue("composite");
      return RequestBody.create(compositeProp, MediaType.get("application/json; charset=utf-8"));
    }

    // If not request body is needed for the post request
    if (integrationConfiguration.getProperty(NO_REQ_BODY) != null) {
      return RequestBody.create(new byte[0]);
    }

    // PropertyState to JSON map of request body
    buildRequestBodyJSON(integrationConfiguration.getValue(reqBodyKey));

    Map<String, Object> attributesWrapper = new HashMap<>();
    attributesWrapper.put("attributes", builtRequestBody);

    // Add checksum to request body if it exists
    if (integrationConfiguration.getValue(CHECKSUM_IN_REQ_BODY) != null) {
      attributesWrapper.put(CHECKSUM_IN_REQ_BODY, integrationConfiguration.getValue(CHECKSUM_IN_REQ_BODY).toString());
    }
    Map<String, Object> dataWrapper = Collections.singletonMap("data", attributesWrapper);

    Document doc = integrationConfiguration.getValue(DOCUMENT);
    if (doc != null) {

      // Create a temporary file and copy the InputStream into it
      String fileName = doc.getFileName();
      String fileNameWithoutExtension = fileName.substring(0, doc.getFileName().lastIndexOf("."));
      File tempFile = null;
      FileOutputStream out = null;
      try {
        tempFile = File.createTempFile(fileNameWithoutExtension, "." + doc.getExtension());
        out = new FileOutputStream(tempFile);
        IOUtils.copy(doc.getInputStream(), out);
      } finally {
        // Create MultipartBody
        String jsonString = new ObjectMapper().writeValueAsString(dataWrapper);
        // Determine media type based on file extension
        String contentType = Files.probeContentType(tempFile.toPath());
        if (contentType == null) {
          contentType = "application/octet-stream";  // Default to octet stream if type is unknown
        }
        RequestBody fileBody = RequestBody.create(tempFile, MediaType.parse(contentType));
        if (out != null) {
          out.close();
        }
        if (tempFile != null) {
          tempFile.deleteOnExit();
        }
        return new MultipartBody.Builder()
            .setType(MultipartBody.FORM)
            .addFormDataPart("content", fileName, fileBody)
            .addFormDataPart("metadata", null, RequestBody.create(jsonString, MediaType.parse("application/json")))
            .build();
      }
    }

    String jsonString = new ObjectMapper().writeValueAsString(dataWrapper);
/*    System.out.println(jsonString);*/
    return RequestBody.create(jsonString, MediaType.get("application/json; charset=utf-8"));
  }

  @Override
  public void executePost() throws IOException, MimeTypeException {
      httpService.post(pathNameModified, getCompletedRequestBody());
  }

  @Override
  public void executePatch() throws IOException, MimeTypeException {
    httpService.patch(pathNameModified, getCompletedRequestBody());
  }

  @Override
  public void executeDelete() throws IOException, MimeTypeException {
    httpService.delete(pathNameModified);
  }
}
